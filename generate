#!/usr/bin/env node

const fs = require('fs');

const toArray = file => fs.readFileSync(file).toString('utf-8').trim().split("\n")

String.prototype.regexIndexOf =function(regex, startpos) {
	const indexOf = this.substring(startpos || 0).search(regex)
	return indexOf >= 0
	    ? indexOf + (startpos || 0)
	    : indexOf;
}

String.prototype.format = function() {
	let index = 0, next = 0, output = "";
    while((next = this.regexIndexOf('\\{([0-9]*?)\\}', index)) != -1) {
        output += this.substring(index, next);
        const number = this.substring(next + 1, this.indexOf('}', next + 1))
    	output += arguments[parseInt(number, 10) - 1]
    	index = next + number.length + 2
    }
    output += this.substring(index, this.length)
    return output;
};

const parseArgs = (args, positions) => {
	const map = {
		pos: {},
		list: [],
	};

	const popSet = (set, args) => Array.isArray(set) ? map.list.push(set) && args.splice(0, 2) : null;
	const defaultReader = (map, arg, name) => {
		const boolean = !arg || arg[0] === '-';
		map.pos[name] = boolean ? true : arg;
		return boolean ? 1 : 2;
	}

	while(args.length > 0) {
		if (!positions.some(position => {
			if(position.indexOf(args[0]) != -1) {
				const name = position[1].substring(2, position[1].length);
				const reader = position[2] || defaultReader;
				args.splice(0, reader(map, args[1], name) || 1);
				return true
			}
		})) {
			map.list.push(toArray(args[0]));
			args.shift();
		}
	}

	return map;
};

/**
 * Parse arguments
 */
const args = parseArgs(process.argv.slice(2), [
	['-f', '--format'], 
	['-r', '--rate'], 
	['-d', '--dry-run'], 
	['-m', '--max'], 
	['-p', '--prepend'],
	['-a', '--append'],
	['-c', '--columns'],
	['-j', '--json', (map, arg) => { map.list.push(JSON.parse(arg)); return 2; }],
	['-t', '--text', (map, arg) => { map.list.push(arg.split(/\s+/)); return 2; }],
]);

const sets = args.list;
const dryRun = args.pos["dry-run"] || false;
const append = args.pos.append || "";
const prepend = args.pos.prepend || "";
const columns = parseInt(args.pos.columns, 10) || sets.length;
const format = args.pos.format || [...Array(columns).keys()].reduce((acc, i) => acc += `{${i + 1}}`, "");
var max = parseInt(args.pos.max, 10) || Number.MAX_SAFE_INTEGER;
const oneEveryX = parseInt(args.pos.rate, 10) || 1;

/**
 * Calculate operation's size
 */
const setModForPlainIndex = []
let total = 1;
for (var i = columns - 1; i >= 0; i--) {
	total *= sets[i % sets.length].length;
	setModForPlainIndex.unshift(sets[i % sets.length].length * setModForPlainIndex[0] || 1);
}

/**
 * Check if dry run
 */
if(dryRun) {
	const maxByRate = Math.ceil(total / oneEveryX)
	console.log(`\nTotal combinations: ${total};`);
	console.log(`This process will generate ` + (max > maxByRate
		? `1 result every ${oneEveryX}: ${maxByRate} in total.\n`
		: `${max} results in total.\n`));

	console.log("Example format:\n")
	max = 1;
}

/**
 * Generate cartesian product
 */
let index = 0;
let numberOfOperations = 0
while(index < total && numberOfOperations < max) {
	const next = [];
	for(var setIndex = 0; setIndex < columns; setIndex += 1) {
		const set = sets[setIndex % sets.length];
		const mod = setModForPlainIndex[setIndex];
		next.push(set[Math.floor(index / mod) % set.length])
	}
	index += oneEveryX;
	numberOfOperations += 1;

	console.log(`${prepend}${format.format(...next)}${append}`)
}
		