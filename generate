#!/usr/bin/env node

const readline = require('readline');
const fs = require('fs');

const toArray = file => fs.readFileSync(file).toString('utf-8').trim().split("\n")

String.prototype.regexIndexOf =function(regex, startpos) {
	const indexOf = this.substring(startpos || 0).search(regex)
	return indexOf >= 0
	    ? indexOf + (startpos || 0)
	    : indexOf;
}

String.prototype.format = function() {
	let index = 0, next = 0, output = "";
    while((next = this.regexIndexOf('\\{([0-9]*?)\\}', index)) != -1) {
        output += this.substring(index, next);
        const number = this.substring(next + 1, this.indexOf('}', next + 1))
    	output += arguments[parseInt(number, 10) - 1]
    	index = next + number.length + 2
    }
    output += this.substring(index, this.length)
    return output;
};

const parseArgs = (args, positions) => {
	const map = {
		pos: {},
		list: [],
	};

	while(args.length > 0) {
		if (!positions.some(position => {
			if(position.indexOf(args[0]) != -1) {
				const boolean = !args[1] || args[1][0] === '-';
				map.pos[position[1].substring(2, position[1].length)] = boolean ? true : args[1];
				args.splice(0, boolean ? 1 : 2);
				return true
			}
		})) {
			map.list.push(args[0]);
			args.shift();
		}
	}

	return map;
};

/**
 * Parse arguments
 */
const args = parseArgs(process.argv.slice(2), [['-f', '--format'], ['-r', '--rate'], ['-d', '--dry-run'], ['-m', '--max']])

const format = args.pos.format || files.reduce((acc, _, i) => acc += `{${i + 1}}`, "");
const dryRun = args.pos["dry-run"] || false;
var max = parseInt(args.pos.max, 10) || Number.MAX_SAFE_INTEGER;
const oneEveryX = parseInt(args.pos.rate, 10) || 1;
const files = args.list;

/**
 * Create sets
 */
const sets = []
const setSizes = []
let total = 1;
for (var i = files.length - 1; i >= 0; i--) {
	const set = toArray(files[i])
	total *= set.length;
	setSizes.unshift(set.length * setSizes[0] || 1);
	sets.unshift(set)
}

/**
 * Check if dry run
 */
if(dryRun) {
	const maxByRate = Math.floor(total / oneEveryX)
	console.log("\nArguments:\n\n", args);
	console.log(`\nTotal combinations: ${total};`);
	console.log(`This process will generate ` + (max > maxByRate
		? `1 result every ${oneEveryX}: ${maxByRate} in total.\n`
		: `${max} results in total.\n`));

	console.log("Example format:\n")
	max = 1;
}

/**
 * Generate cartesian product
 */
let index = 0;
let numberOfOperations = 0
while(index < total && numberOfOperations < max) {
	const next = [];
	sets.forEach((domain, domainIndex) => {
		next.push(domain[Math.floor(index / setSizes[domainIndex]) % domain.length])
	})
	index += oneEveryX;
	numberOfOperations += 1;

	console.log(format.format(...next))
}
		